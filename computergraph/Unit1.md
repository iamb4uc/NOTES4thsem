# Unit 1

##### Q1: What is computer graphics? Write down the applications of computer graphics also mention some graphic packages.
It is the creation and manipulation of  graphic images by means of a computer. Computer graphics started a technique to enhance the display information generated by a computer. This ability to interpret and represent numerical data in pictures has significantly increased the computer's ability to present information to the users in a clear and understandable form ie large bar-charts, pie-charts, and graphs.  
**Applications of computer graphics**:
  1. Computer Aided Design(*CAD*)
  2. Computer Aided Geometric Design(*CAGD*)
  3. Entertainment(animation, games etc)
  4. Computer art
  5. Presentation graphics
  6. Education and Training
  7. Geographic Information System(*GIS*)
  8. Visualization(*Scientific Visualization, Information Visualization*)
  9. Medical Visualization
  10. Image processing
  11. Graphical user interface(*GUI*)

***Graphics packages***: A set of libraries that provide programmatically access to some kind of graphic 2D function.  

**Types:**
  1. GKS(*Graphics Kernel System*): First Graphic packages accepted by ISO and  ANSI.
  2. PHIGS(*Programmers Hierarchical Interactive Graphics Standard*): Accepted  by ISO and ANSI
  3. PHIGS+ (*Expanded Package*)
  4. Silicon graphics GL(*Graphic Library*)
  5. OpenGL
  6. Pixer Render Man Interface.
  7. Postscript interpreters.
  8. Painting, drawing, design packages.

#### Architecture Of Graphics System
This component of a raster system contains display processor, display processor memory, frame buffer, video controller and I/O devices.  

![architecture(raster System)](IMG/architectureU1.jpg)  

Fig: Architecture of Graphic System  

##### Q2: What is pixel? How pixel are represented in computer memory? ***
Pixel is the smallest piece of information of an images.
- Pixels are normally arranged in a regular 2D grid, and are often represented using dots or squares.
- Each pixel is a sample of an original image where more samples typically provide a more accurate representation of the original.
- The intensity of each pixel is variable in color systems, each pixel has typically three or four components such as *Red, Green, and Blue* or *Cyan, Magenta, Yellow and Key(black)*.  


##### Q3: Define display processors. How characters can be represented using display processors?
Purposes: It frees the CPU from graphics routine task.  
The major task is to digitize a picture definition given in an application program into a set of pixel values for storage in the frame buffer. This digitization process is called scan conversion.
- Straight lines and other geometric objects are scan conversion into a set of discrete points, corresponding to screen pixel location.  
Characters can be defined with rectangular pixel grids or they can be defined with outline shapes. The array size for character grids can vary from 5x7 to 9x12 or more for higher quality displays.  
![](IMG/co65.png)  
A character grid is displayed by super imposing the rectangular grid pattern into the frame buffer at a specified co-ordinate position.  
For characters that are defined as outlines the shapes are scanned converted into the frame buffer by locating the pixels positions closet to the outline.

##### Q4: Define frame buffer. ***

Each screen pixel corresponds to particular entry in a 2D array
residing in memory. This memory is called a frame buffer or a bit map.
The number of rows in the frame buffer equals to the number of raster
lines on the display screen.  

The number of columns in this array equals to the number of pixel on
each raster line. The term pixel is also used to describe the row and
column location in frame buffer array that corresponds to the screen
location. A 512x512 display screen requires **262144** pixel memory
locations.  

Whenever we wish to display a pixel on the screen, a specific value is
place into the corresponding memory location in the frame buffer
array.  

Each screen pixel location and corresponding memory location in the
frame buffer is accused by the non-negative integer co-ordinate
point(x,y).  

The X-value refers to the columns, the Y-values to row position.  
The origin of this co-ordinate system is positioned at the bottom left corner of the screen or it is positioned at the upper left corner of the screen.  

![fig1](IMG/frameb1.png) ![fig1](IMG/frameb2.png)

##### Q5: Define:
  - Refresh rate: It is the number of times per second the display hardware updates its information. It is similar to blinking  of eyes in human visual system. Blinking in humans is also for refreshing. There is less flickering effect for more refresh   rate in center display units. But too much refresh rate may distort  

  - Frame rate:
  - CGA(*Color Graphics Adopter*): It is a hardware video display standard. CGA uses 16 kilobytes of V-RAM. It supports 4bit  colors, that means it has 16 different colors. It supports highest resolution of 640x200.  

  - VGA(*Video Graphic Array*): It is a display hardware which supports highest resolution of 640x480. VGA supports 8bit colors   and has maximum 256 colors.  

  - Resolution: Resolution of an image refers to the total number of pixels along the entire height and weight of image.  
  *Example: A full screen image with resolution 800x600 means that there are 800 columns of pixels, each column comprising  600pixels ie a total of 800x600 is equal to 4,80,000 pixels in the image area.*   

  - Mega Pixel: A mega pixel is a unit of image sensing capacity in a digital device. Mega pixel constitutes of millions of   pixels. In general, the more mega pixel is in a device the better the resolution, when printing an image in a given size. A   digital camera with a 1.3 mega pixel resolution will print a good quality 4x3 inch print at 300dpi(dot per inch).  

  - Refreshing: In a raster scan system, the electron beam is swept across the screen one row at a time from top to bottom. As  the electron beam move across each row, the beam intensity is turned on and off to create a pattern is called refreshing.  

  - Frame: Each complete scanning of a screen is normally called a frame.  

  - Bitmap: On black and white system ie, on monochrome system the frame buffer storing the values of pixels is called a bit  map. Each entry in the bit map is the one bit data which determines the on(1) and off(0) of the intensity of the pixel.  

  - Pixmap: On color system, the frame buffer storing the values of the pixel is called a pix map. Each entry in the pix map  occupies a number of bits to represent the color of the pixels. For a true color, display the number of bits for each entry   is *24(2^3 = 8 bits per RGB channel, 2^8 = 256 level of intensity value ie, 256 voltage settings for each of the RGB  electron guns)*  

  - Aspect Ratio: The aspect ratio of a picture is the ratio of its width to its height. It is normally shown by two numbers  separated by colon as in **4:3**. Here, the primary number tells that the picture is 4 unit wide and the subsequent number  tells that the picture is 3 unit high.  


##### Q6: Explain Raster Scan System and Random Scan System.  
***Raster Scan Display***: In a raster scan system the electron beam is swept across the screen on row at a time from top to bottom. As the electron beam moves across each row, the beam intensity is turned on and off to create a pattern of illuminated spots.
Raster scan displays is based on the CRT technology.  
![raster scan system](IMG/Rscansys.jpg)  
FIG: Electrostatic deflection of the electron beam  
Picture definition is stored in a memory area called the refresh buffer. This memory area holds the set of intensity values for all screen points. These stored intensity values are then retrieved from the refresh buffer and used to control the intensity of the electron beam as it moves from the spot across the screen.  
Refreshing on raster scan display is arrived out at the rate of 60 to 80 frames per second although some systems are designed for higher refresh rates. Sometimes, refresh rates are described in unit of cycles per second or Hertz(Hz). Where a cycle corresponds to one frame. At the end of each scan line, the electron beam returns to the left side of the screen to begin displaying the next scan line, the return to the left of the screen after refreshing each scan line horizontal retrace of electron beam. And at the end of each frame, the electron beam returns(vertical retrace) to the top left corner of the screen to begin the next frame.  
![Refreshing on raster scan](IMG/Rscanref.jpg)  

***Random Scan System***: When operated as random scan display unit, a CRT has the electron beam directed only to the parts of the screen where a picture is to be drawn. Random scan monitors draw a picture one line at a time and for this reason are also referred to as vector displays or crystallographic display.  
![Random Scan Display](IMG/ranscan.png)  

##### Q7: Difference between Raster Scan System and Random Scan System.
Difference between Raster Scan system and Random scan system is as follows:  

Serial | Raster Scan System | Random Scan System |
------ | -------------------|------------------- |
1 | The beam is moved all over the screen, one scan line at a time from top to bottom(horizontal retrace) and the back to top(vertical retrace). | The beam is moved between the end points of the graphics primitive. |
2 | Picture definition is stored as a set of intensity value of for all screen points called pixels in a refresh buffer area. | Picture definition is stored as a set of line drawing instruction in a display file. |
3 | Raster scan has ability to display areas filled with solid colors on patterns. | Random scan display draws only lines and characters. |
4 | It is less expensive. | It is more expensive. |
5 | It uses interlacing. | Interlacing is not used. |
6 | In this, resolution is less. | Resolution is high. |
7 | Uses monochrome or shadow mask type. | Uses monochrome or beam penetration type. |
8 | Raster scan display smooth lines by approximating them with pixel. | Random scan display draw a continuous and smooth lines . |
9 | Refresh rate independent of picture complexity. | Refresh rate depends directly on picture complexity. |
10 | Uses scan conversion. | Scan conversion is not required. |

##### Q8: Explain the principle of CRT Technologies.
A Cathode Ray Tube(CRT) is a specialized vacuum tube in which image are produced when an electron beam stickers a [phosphorescent](https://en.wikipedia.org/wiki/Phosphorescence) screen. Most desktop computer displays make sure of CRTs. The CRT in a computer display is similar to the picture tube in a television receiver. A cathode ray tube consists of several basic components as illustrated below. The electron gun generates a narrow beam of electrons. The anodes accelerate the electrons. Deflecting coils produce an extremely low frequency electro magnetic field that allows for constant adjustment of the direction of the electron beam. There are two sets of deflecting coils: horizontal and vertical. The intensity of the beam can be varied. The electron beam produces a tiny, bright visible spot when it strikes the phosphor coated screen.  
![workings of a CRT screen](IMG/crt.png)  

To produce an image on the screen, complex signals are applied to the deflecting coils and also to the apparatus that controls the intensity of the electron beam. This causes the spot to race across the screen from right to left and from top to bottom, in a sequence of horizontal lines called raster as viewed from the front of the CRT, the spot moves in a pattern similar to the way that eyes move when reading a single column page of text but the scanning takes place as such a rapid that our eyes sees a constant image over the entire screen.  
The illustration show only one electro-gun.

##### Q9: Consider a raster system with a resolution of 640x480. Find the size of the frame buffer in bytes to store it if 12bits/pixel are fixed.  
Given, resolution = 640 * 480  
1 pixel can store = 12 bits  
then the size of the frame buffer in memory(in Megabytes):  
![step1](https://latex.codecogs.com/gif.latex?%5BMB%20%3D%20%5Cfrac%7Bx%5C%3B%20resolution*y%5C%3B%20resolution*%5Cfrac%7Bbits%7D%7Bpixel%7D%7D%7B8*1024*1024%7D%5D)  

![step2](https://latex.codecogs.com/gif.latex?%3D%20%5Cfrac%7B640*480*12%7D%7B8*1024*1024%7D)  

![step3](https://latex.codecogs.com/gif.latex?%3D%5Cfrac%7B3686400%7D%7B8388608%7D%20%3D%200.439%20%5Csimeq%200.44%20byte) which is required  

##### Q10: How much time is spent in scanning across each row of pixels during screen refresh on a raster system with a resolution of 1280x1024 and refresh rate of 60FPS/Hz.  
Here, resolution ![1024x1024](https://latex.codecogs.com/gif.latex?%3D%201024%5Ctimes%201024)  
It means that 1024 scan lines takes ![1/60](https://latex.codecogs.com/gif.latex?%5Cfrac%20%7B1%7D%7B60%7D) sec.  
![Therefore](https://latex.codecogs.com/gif.latex?%5Ctherefore) *1 scan line takes =* ![\frac {1}{60\times 1024}sec=\frac {1}{61440}=0.0058](https://latex.codecogs.com/gif.latex?%5Cfrac%20%7B1%7D%7B60%5Ctimes%201024%7Dsec%3D%5Cfrac%20%7B1%7D%7B61440%7D%3D0.0058) *seconds.*

##### Q11: If the screen resolution is 600x400 and the frames/second is 30, find out the time required to transfer 1 pixel.
Here, resolution = ![600\times 400](https://latex.codecogs.com/gif.latex?600%5Ctimes%20400)  
that means system contains 400 scan lines and each scan line contains 600 pixels.  
refresh rate ![= 30 frames/seconds](https://latex.codecogs.com/gif.latex?%3D%2030%20frames/seconds)  

1 frame takes ![= \frac {1}{30}](https://latex.codecogs.com/gif.latex?%3D%20%5Cfrac%20%7B1%7D%7B30%7D)  

![Therefore](https://latex.codecogs.com/gif.latex?%5Ctherefore) *resolution* = ![600\times 400](https://latex.codecogs.com/gif.latex?600%5Ctimes%20400)*, 1 frame buffer consists of 400 scan lines.*  

It means that 400 scan lines takes ![=\frac {1}{30}sec](https://latex.codecogs.com/gif.latex?%3D%5Cfrac%20%7B1%7D%7B30%7Dsec)  

1 scan line takes ![=\frac {1}{30\times 400}sec=\frac {1}{12000}sec=0.00008 sec](https://latex.codecogs.com/gif.latex?%3D%5Cfrac%20%7B1%7D%7B30%5Ctimes%20400%7Dsec%3D%5Cfrac%20%7B1%7D%7B12000%7Dsec%3D0.00008%20sec)

##### Q12: What is the aspect ratio of 12inch x 16inch display.
Factors of 12 and 16 are  
![12factor](https://latex.codecogs.com/gif.latex?12%20%3D%202*2*3)  
![16factor](https://latex.codecogs.com/gif.latex?16%3D2*2*2*2)  
common denomenator is 4  
Now we have to find the aspect ratio ie ![x:y](https://latex.codecogs.com/gif.latex?x%3Ay):  
*x = CRT weidth/common denomenator =* ![12/4](https://latex.codecogs.com/gif.latex?%5Cfrac%7B12%7D%7B4%7D%3D3)  
*y = CRT height/common denomenator =* ![16/4](https://latex.codecogs.com/gif.latex?%5Cfrac%7B16%7D%7B4%7D%3D4)  
![Therefore](https://latex.codecogs.com/gif.latex?%5Ctherefore) Aspect ratio is ![3:4](https://latex.codecogs.com/gif.latex?3%3A4)  

### Interactive Input/Output Device
###### Input/Output device used for computer graphics:
***Input Devices:*** Various hardware devices have been develop to enable the user to interact in the more natural manner. These devices can be separated into two classes. They are:  
1. **Locators**: Locators are the devices which give position information. The computer reveives from a locator, the co-ordinates for a point. Using a locator we can indicate a position on the screeen. The different locators are as follows:
	* *Joysticks*: A joystick has two potentiometers. They have been attached to a single lever. Moving the lever forward and backwards changes the settings on one potentiometer.
	* *Mouse*: An input device that enables us to edit and manipulate.  For example: *in terms of computer graphics, the mouse can be used to crop and image or to use the magic wand tool etc.*
	* *Tablet*: A tablet composed of a flat surface and a pen like stylus or window like tablet cursor. The tablet is able to sense the position of the stylus.
2. **Selector**: Selector devices are used to detect the particular graphical object. A selector may pick a particular item but provide no information about that item is located on the screen. The different selector devices are as follows:
	* *Light Pen*: A input device that allows us to draw on a screen with greater positional accuracy, similarly to how we would on a graphic tablet. It can also be used to point it displayed object.
	* *Keyboard*: The keyboard is an efficient device for inputing such non-graphic data. Cursor control keys and function keys are common features on general purpose keyboards. Additional numeric keyboard is often included on the keyboard for fast entry of numeric data.
	* *Trackball and Space-ball*: The space-ball and trackball are used to accurately draw on the computer. Trackballs and space balls are mainly seen or used for arcade games.
	* *Data glove*: A data glove is a glove which has been wired up with wax which sense movements. These sensors are connected to the computer which then sense the movement of the hand to get information across.
	* *Digitizers*: An input device that allows us to hand draw graphics an images or a flat screen using a stylus where we can also do painting, selecting, dragging and move.
	* *Scanners*: An input device that allows us to scan an image, poster, photograph etc which can then be uploaded and edited in a graphic software package.
	* *Touch Panels*: Touch panels allow displayed object or screen positions to be selected with the touch of a finger. Touch input can be recorded using three methods, namely optical touch panels, electrical touch panels and acoustical touch panels.
	* *Voice Systems*: Speech recognition is used in some graphic workstations as input devices to accept voice command. The voice system can be used to initiate graphics operations or to enter data.

#### Output Devices:
* *Printers*: This allow us to print of the graphics with create and edit on the computer. We can print them off in color, black and white or gray scale in various sizes.
* *Plotters*: Plotter is another type of computer printer which prints vector graphics. There are two types of plotters: One is a pen plotter which is when a pen moves across the surface of the paper and then there is a knife plotter which uses moving knives to cut into a piece material.
* *Monitors*: This allows us to see the images produced by the computer. The quality of the graphics that we sea depends on the size and the resolution of the monitors.
* *Phosphors*: The phosphors used in a graphic display are normally chosen for their color characteristics and persistence color should preferably white particularly for applicants where dark information appears on a light background.
* *Electron guns*: Electron gun makes use of electro static fields to focus and accelerate the electron beam. A field is generated when two surfaces are raised to different potentials.

## Bresenhams's line drawing algorithm:
Let us consider the line in the fig where P is the previously selected pixels and E and NE are two pixels from which we choose at the next stage. Let Q be the intersection point of the line being scan converted with the grid line ![x=xp+1](https://latex.codecogs.com/gif.latex?x%3Dx_p&plus;1)
![Diagram](IMG/Bresenhamsdiagram.png)  
The difference between vertical distances from E and NE to Q is computed and the sign of the difference is used to select the pixel whose distance from Q is smaller as the best approximation to the line. If the mid point M lies above the line, the pixel E is chosen to the line; if the mid point lies below the line pixel NE is chosen to the line.  
Let us consider the straight line by the equation  
![f(x,y)=ax+by+c=0](https://latex.codecogs.com/gif.latex?f%28x%2Cy%29%3Dax&plus;by&plus;c%3D0..............................%281%29)  

The equation straight line can be written as  
![y=mx+b](https://latex.codecogs.com/gif.latex?y%3Dmx&plus;b)  

![or =\frac{dy}{dx}x+b](https://latex.codecogs.com/gif.latex?or%20%3D%5Cfrac%7Bdy%7D%7Bdx%7Dx&plus;b)  

or ![ydx=xdy+Bdx](https://latex.codecogs.com/gif.latex?ydx%3Dxdy&plus;Bdx)  
or ![xdy-ydx+bdx=0](https://latex.codecogs.com/gif.latex?xdy-ydx&plus;Bdx%3D0.........................................%282%29)  

Comparing 1 and 2, we get  
![a=dy,b=-dx,c=Bdx](https://latex.codecogs.com/gif.latex?a%3Ddy%2C%20b%3D-dx%2C%20c%3DBdx)  

![F(x,y)=0,](https://latex.codecogs.com/gif.latex?F%28x%2Cy%29%3D0%2C) *for points on the straight line*  
![F(x,y)>0,](https://latex.codecogs.com/gif.latex?F%28x%2Cy%29%3E0%2C) *for points below the straight line*  
![F(x,y)<0,](https://latex.codecogs.com/gif.latex?F%28x%2Cy%29%3C0%2C) *for points above the straight line*  
We now consider the decision variable.  
![(x_p+1, y_p+\frac {1}{2})](https://latex.codecogs.com/gif.latex?d%28old%29%3DF%28x_p&plus;1%2C%20y_p&plus;%5Cfrac%20%7B1%7D%7B2%7D%29), [where ![(x_p+1, y_p+\frac {1}{2})](https://latex.codecogs.com/gif.latex?%28x_p&plus;1%2C%20y_p&plus;%5Cfrac%20%7B1%7D%7B2%7D%29) is the co-ordinates of the mid point M]  
![=a(x_p+1)+b(1_p+\frac {1}{2})+c](https://latex.codecogs.com/gif.latex?%3Da%28x_p&plus;1%29&plus;b%281_p&plus;%5Cfrac%20%7B1%7D%7B2%7D%29&plus;c)  

If d>0, we choose the pixel NE  
If d<0, we choose the pixel E  
If d=0, we choose either of the pixels, so we pick E.  
If E is chosen, M is incremented by 1 step in x direction and we get  
![d(new)=F(x_p+2,y_p+\frac {1}{2})](https://latex.codecogs.com/gif.latex?d%28new%29%3DF%28x_p&plus;2%2Cy_p&plus;%5Cfrac%20%7B1%7D%7B2%7D%29)  
![=a(x_p+2)+b(y_p+\frac {1}{2})+c](https://latex.codecogs.com/gif.latex?%3Da%28x_p&plus;2%29&plus;b%28y_p&plus;%5Cfrac%20%7B1%7D%7B2%7D%29&plus;c)  

![d(new)-d(old)=a(x_p+2)+b(y_p+\frac {1}{2})+c-a(x_p+1)-b(y_p+\frac {1}{2})-c=a](https://latex.codecogs.com/gif.latex?d%28new%29-d%28old%29%3Da%28x_p&plus;2%29&plus;b%28y_p&plus;%5Cfrac%20%7B1%7D%7B2%7D%29&plus;c-a%28x_p&plus;1%29-b%28y_p&plus;%5Cfrac%20%7B1%7D%7B2%7D%29-c%3Da)  
If NE is chosen then M is incremented in both x and y directions by 1 unit. In this:  

![d(new)=d(old)+a+b](https://latex.codecogs.com/gif.latex?d%28new%29%3Dd%28old%29&plus;a&plus;b)  
![=F(x_p+2,y_p+\frac {3}{2})](https://latex.codecogs.com/gif.latex?%3DF%28x_p&plus;2%2Cy_p&plus;%5Cfrac%20%7B3%7D%7B2%7D%29)  
![=a(x_p+2)+b(y_p+\frac {3}{2})+c](https://latex.codecogs.com/gif.latex?%3Da%28x_p&plus;2%29&plus;b%28y_p&plus;%5Cfrac%20%7B3%7D%7B2%7D%29&plus;c)  

![d(new)-d(old)=a(x_p+2)+b(y_p+\frac {3}{2})+c-a(x_p+1)+b(y_p+\frac {1}{2})-c=a+b](https://latex.codecogs.com/gif.latex?d%28new%29-d%28old%29%3Da%28x_p&plus;2%29&plus;b%28y_p&plus;%5Cfrac%20%7B3%7D%7B2%7D%29&plus;c-a%28x_p&plus;1%29&plus;b%28y_p&plus;%5Cfrac%20%7B1%7D%7B2%7D%29-c%3Da&plus;b)  
![d(new)=d(old)+a+b](https://latex.codecogs.com/gif.latex?d%28new%29%3Dd%28old%29&plus;a&plus;b)  
Since the first pixel is simply the first end point ![(x_o,y_o)](https://latex.codecogs.com/gif.latex?%28x_o%2Cy_o%29), we can directly calculate the initial value of d for choosing between E and NE.
The first mid point is at  
![(x_o+1,y_o+\frac {1}{2})and\; F(x_o+1,y_o+\frac {1}{2})=a(x_o+1)+b(y_o+\frac {1}{2})+c](https://latex.codecogs.com/gif.latex?%28x_o&plus;1%2Cy_o&plus;%5Cfrac%20%7B1%7D%7B2%7D%29and%5C%3B%20F%28x_o&plus;1%2Cy_o&plus;%5Cfrac%20%7B1%7D%7B2%7D%29%3Da%28x_o&plus;1%29&plus;b%28y_o&plus;%5Cfrac%20%7B1%7D%7B2%7D%29&plus;c)  
![=ax_o+a+by_o+\frac {b}{2}+c](https://latex.codecogs.com/gif.latex?%3Dax_o&plus;a&plus;by_o&plus;%5Cfrac%20%7Bb%7D%7B2%7D&plus;c)  
![=ax_o+by_o+c+a+\frac {b}{2}](https://latex.codecogs.com/gif.latex?%3Dax_o&plus;by_o&plus;c&plus;a&plus;%5Cfrac%20%7Bb%7D%7B2%7D)  
![a+\frac {b}{2}](https://latex.codecogs.com/gif.latex?%5Csmall%20%3Da&plus;%5Cfrac%20%7Bb%7D%7B2%7D%5C%3B%20%5B%5Cbecause%20%28x_o%2Cy_o%29is%5C%2C%20on%5C%2C%20the%5C%2C%20straight%5C%2C%20line%5C%2C%20ax&plus;by&plus;c%3D0%5C%2C%20we%5C%2C%20get%5C%2C%20ax_o&plus;by_o&plus;c%3D0%5D)  

Thus, ![d(start)=F(x_0+1,y_o+\frac {1}{2})=a+\frac {b}{2}=dy-\frac{dx}{2}](https://latex.codecogs.com/gif.latex?%5Csmall%20d%28start%29%3DF%28x_0&plus;1%2Cy_o&plus;%5Cfrac%20%7B1%7D%7B2%7D%29%3Da&plus;%5Cfrac%20%7Bb%7D%7B2%7D%3Ddy-%5Cfrac%7Bdx%7D%7B2%7D)  
Using ![d(start)](https://latex.codecogs.com/gif.latex?%5Csmall%20d%28start%29), we can choose the 2nd pixel and so on.  
To eliminate the fraction in ![d(start)](https://latex.codecogs.com/gif.latex?%5Csmall%20d%28start%29), we define the original equation ![F(x,y)=0](https://latex.codecogs.com/gif.latex?%5Csmall%20F%28x%2Cy%29%3D0) by multiplying it by 2, ie, ![F(x,y)=2(ax+by+c)](https://latex.codecogs.com/gif.latex?%5Csmall%20F%28x%2Cy%29%3D2%28ax&plus;by&plus;c%29)  
This multiplies each constant and the decision variable by 2, but does not effect the sign of the decision variable.


##### Q13: Write an algorithm to draw a straight line between the points![(x_o,y_o)](https://latex.codecogs.com/gif.latex?%28x_o%2Cy_o%29) and ![(x_1,y_1)](https://latex.codecogs.com/gif.latex?%5Csmall%20%28x_1%2Cy_1%29) using Bresenham's line drawing or mid point algorithm.  

<!-- Algorithm -->
```c
Bresenhams line(x0, y0, x1, y1, color)
int x0, y0, x1, y1, color
/* We want to draw a straight line from (x0+y) to (x1+y1) color gives the pixels color */
{
  int dx, dy, incrE, incrNE, d, x, y;
  dx = x1 - x0;
  dy = y1 - y0;
  d = 2 * dy - dx;
  incrE = 2 * dy;
  incrNE = 2 * (dy - dx);
  x = x0;
  y = y0;
  put pixel(x, y, color);
  while(x < x1)
  {
    if(d <= 0)
    {
      d = d + incrE;
      x = x + 1;
    }
    else
    {
      d = d + incrNE;
      x = x + 1;
      y = y + 1;
    }
    put pixel(x, y, color);
  }
}
```
## Bresenham's Circle drawing algorithm:
Assuming the center of the circle is at the origin. In the below figure for a point.  
![circle](IMG/Bresenhamscircle.png)  
(h,k), we can draw a total of 8 points on the circle. Hence, we need to draw a curve from A to B, where ![\angle AOB = 45\degree](https://latex.codecogs.com/gif.latex?%5Csmall%20%5Cangle%20AOB%20%3D%2045%5Cdegree).  

Let the equation of the circle be  
![F(x,y)=x^2+y^2-R^2=0](https://latex.codecogs.com/gif.latex?%5Csmall%20F%28x%2Cy%29%3Dx%5E2&plus;y%5E2-R%5E2%3D0) where R is the radius of the circle.  
Let us now consider the following fig
![someshit](IMG/Bcirclesomeshit.png)  
Hence ![(x_p, y_p)](https://latex.codecogs.com/gif.latex?%5Csmall%20%28x_p%2C%20y_p%29) is a previously selected pixel. We want to draw the next pixel which is either E or SE. The co-ordinate of the mid point is ![M(x_p+1, y_p-\frac {1}{2})](https://latex.codecogs.com/gif.latex?%5Csmall%20M%28x_p&plus;1%2C%20y_p-%5Cfrac%20%7B1%7D%7B2%7D%29)  
We now chose the decision variable:  
![d(old)=F(x_p+1, y_p-\frac {1}{2})](https://latex.codecogs.com/gif.latex?%5Csmall%20d%28old%29%3DF%28x_p&plus;1%2C%20y_p-%5Cfrac%20%7B1%7D%7B2%7D%29)  
![d(old)=(x_p+2)^2+(y_p-\frac {1}{2})^2-R^2](https://latex.codecogs.com/gif.latex?d%28old%29%3D%28x_p&plus;2%29%5E2&plus;%28y_p-%5Cfrac%20%7B1%7D%7B2%7D%29%5E2-R%5E2..................%281%29)  
If d > 0, we choose the pixel SE  
If d < 0, we choose the pixel E  
If d = 0, we choose either of the pixels and so, we pick E  
when E is chosen,  
![d(new)=F(x_p+2, y_p-\frac {1}{2})](https://latex.codecogs.com/gif.latex?d%28new%29%3DF%28x_p&plus;2%2C%20y_p-%5Cfrac%20%7B1%7D%7B2%7D%29)  
![=(x_p+2)^2+(y_p-\frac {1}{2})^2-R^2](https://latex.codecogs.com/gif.latex?%3D%28x_p&plus;2%29%5E2&plus;%28y_p-%5Cfrac%20%7B1%7D%7B2%7D%29%5E2-R%5E2........................%282%29)  
![\therefore d(new)-d(old)=2x_p+3](https://latex.codecogs.com/gif.latex?%5Ctherefore%20d%28new%29-d%28old%29%3D2x_p&plus;3)  
where SE is chosen  
![d(new)=F(x_p+2, y_p-\frac {3}{2})](https://latex.codecogs.com/gif.latex?d%28new%29%3DF%28x_p&plus;2%2C%20y_p-%5Cfrac%20%7B3%7D%7B2%7D%29)  
![=(x_p+2)^2+(y_p-\frac {1}{2})^2](https://latex.codecogs.com/gif.latex?%3D%28x_p&plus;2%29%5E2&plus;%28y_p-%5Cfrac%20%7B1%7D%7B2%7D%29%5E2)  
![\therefore d(new)-d(old)=\left \{ 2(x_p-y_p)+5 \right \}](https://latex.codecogs.com/gif.latex?%5Ctherefore%20d%28new%29-d%28old%29%3D%5Cleft%20%5C%7B%202%28x_p-y_p%29&plus;5%20%5Cright%20%5C%7D)  
![or\; d(new)=d(old)+incrSE](https://latex.codecogs.com/gif.latex?or%5C%3B%20d%28new%29%3Dd%28old%29&plus;incrSE)  
where ![incrSE=\left \{ 2(x_p-y_p)+5 \right\}](https://latex.codecogs.com/gif.latex?incrSE%3D%5Cleft%20%5C%7B%202%28x_p-y_p%29&plus;5%20%5Cright%5C%7D)  
The initial value of d is obtained by starting point (O, R) and hence the corresponding mid point will be ![(1, R-\frac {1}{2})](https://latex.codecogs.com/gif.latex?%281%2C%20R-%5Cfrac%20%7B1%7D%7B2%7D%29) and we get  
![d(start)=F(1,R-\frac {1}{2})](https://latex.codecogs.com/gif.latex?d%28start%29%3DF%281%2CR-%5Cfrac%20%7B1%7D%7B2%7D%29)  
![=1^2+(R-\frac {1}{2})^2-R^2](https://latex.codecogs.com/gif.latex?%3D1%5E2&plus;%28R-%5Cfrac%20%7B1%7D%7B2%7D%29%5E2-R%5E2)  

![=-R+1+\frac{1}{4}](https://latex.codecogs.com/gif.latex?%3D-R&plus;1&plus;%5Cfrac%7B1%7D%7B4%7D)  
![=\frac {5}{4}-R\cong (1-R)[Neglecting\; \frac {1}{4}]](https://latex.codecogs.com/gif.latex?%3D%5Cfrac%20%7B5%7D%7B4%7D-R%5Ccong%20%281-R%29%5BNeglecting%5C%3B%20%5Cfrac%20%7B1%7D%7B4%7D%5D)  
##### Q14: Write an algorithm to draw a circle using mid point algorithm or Bresenham's algorithm.
<!-- Algorithm -->
```c
circle_pt(int h, int k, int color)
{
  put pixel(h, k, color);
  put pixel(h, -k, color);
  put pixel(-h, k, color);
  put pixel(-h, -k, color);
  put pixel(k, h, color);
  put pixel(-k, h, color);
  put pixel(k, -h, color);
  put pixel(-k, -h, color);
}


mid point_circle(int radius, int color)
{
  int x, y, incrE, incrSE, d;
  d = 1-radius;
  x = 0;
  y = radius;
  circle-pt(x, y, color)
  while(x < y)
  {
    if (d > 0)
    {
      incrSE = 2*(x-y)+5;
      d += incrSE;
      x += 1;
      y -= 1;
    }
    else
    {
      incrE = 2*x+3;
      d += incrE;
      x += 1;
    }
    circle_pt(x, y, color);
  }
}

```  


## DDA Algorithm (Digital Differential Analyzer/Adapter)
DDA Algorithm uses linear interpolation if variables over an internal between two end points, it is used for rasterization of lines, circle, ellipse etc.  
Example: DDA samples the lines at unit intervals in one co-ordinate corresponding integer values nearest the line path of other co-ordinate.

##### Advantages:
- Faster than the direct use of the line equation *y=mx+c*
- It is simple.  

##### Disadvantages:
- DDA uses floating point variable which is time consuming.
- DDA has rounding operations, hence it gives approximate results.

##### Algorithm:
In the line drawing algorithm, DDA calculates the dy or dx. A line is then sampled at unit intervals in one co-ordinate and corresponding integer values nearest to the line path are determined for the other co-ordinate.  
**Step 1**: ![A=x_1,\; y_1](https://latex.codecogs.com/gif.latex?A%3Dx_1%2C%5C%3B%20y_1)  
![B=x_2,\; y_2](https://latex.codecogs.com/gif.latex?B%3Dx_2%2C%5C%3B%20y_2)  
**Step 2**: ![\bigtriangleup x=x_2-x_1](https://latex.codecogs.com/gif.latex?%5Cbigtriangleup%20x%3Dx_2-x_1) ![diagram](IMG/meh.png)  
![\bigtriangleup y=y_2-y_1](https://latex.codecogs.com/gif.latex?%5Cbigtriangleup%20y%3Dy_2-y_1)  

**Step 3**: If ![\bigtriangleup x >\bigtriangleup y](https://latex.codecogs.com/gif.latex?%5Cbigtriangleup%20x%20%3E%5Cbigtriangleup%20y) then  
![Step=\bigtriangleup x](https://latex.codecogs.com/gif.latex?Step%3D%5Cbigtriangleup%20x)  
else  
![Step=\bigtriangleup y](https://latex.codecogs.com/gif.latex?Step%3D%5Cbigtriangleup%20y)  

**Step 4**: ![x_{incr}=\frac {\bigtriangleup x}{Step}\; \; \; \; \; \; y_{incr}=\frac {\bigtriangleup y}{Step}](https://latex.codecogs.com/gif.latex?x_%7Bincr%7D%3D%5Cfrac%20%7B%5Cbigtriangleup%20x%7D%7BStep%7D%5C%3B%20%5C%3B%20%5C%3B%20%5C%3B%20%5C%3B%20%5C%3B%20y_%7Bincr%7D%3D%5Cfrac%20%7B%5Cbigtriangleup%20y%7D%7BStep%7D)  

**Step 5**: ![x=x_1+0.5\; sign(x_{incr})](https://latex.codecogs.com/gif.latex?x%3Dx_1&plus;0.5%5C%3B%20sign%28x_%7Bincr%7D%29)  
![y=y_1+0.5\; sign(y_{incr})](https://latex.codecogs.com/gif.latex?y%3Dy_1&plus;0.5%5C%3B%20sign%28y_%7Bincr%7D%29)

**Step 6**:  
```c
i = 1;
while(i<=step)
{
  plot(x, y);
  x = x + xincr;
  y = y + yincr;
}
```

#### Region Filling:
Region filling is the process of "coloring" in a definite area or a region.
Region may be described in two ways:
1. At the pixel level and
2. At the geometrical level

1. **At the pixel level**: We describe a region either as the totality of pixel that comprises it or in terms of boundary pixels that outline it. In the first case, the region is called interior defined and corresponding filling algorithm is caleed flood filled algorithm and the second type of the region is called boundary define region and the corresponding filling algorithm is called boundary filling algorithm.
2. **At the geometric level**: At the geometric level, the region is described in terms of objects such as line polygon, circle and so on.

#### Flood fill algorithm:
When flood filling is used, the user will generally provides on initial pixel 'seed'. From the seed, the algorithm will inspact each of the surrounding 8 pixels to determine whether the extent has been reached. The process is repeated untill all pixels inside the region has been inspected.  
![floodfilling algo](IMG/ffalgo.png)  

***Algorithm***:  
In flood fill, fill can be done recursively if we know a seed point(x,y) located inside(*WHITE*). Now scan convert edges into buffer in edge/inside color(*BLACK*).
```c
flood_fill(int x, int y)
{
    if(read_pixel(x,y)==WHITE)
    {
        write_pixel(x,y,BLACK);
	flood_fill(x-1,y);
	flood_fill(x+1,y);
	flood_fill(x,y-1);
	flood_fill(x,y+1);
    }
}
```

#### Boundary filling algorithm:  
In boundary filling, the user will provide initial pixel called 'seed'. The boundary fill algorithm then one by one inspect each pixel to the left and right of the seed. When the left and right most boundary pixels are hit, a run or a line of pixels is drawn. Next the boundary filled algorithm inspect each pixel above and below, the line just drawn. This process is continued until all pixel inspected are to the boundary pixels.  
The boundary fill algorithm/function module is as follows:
```c
boundary_fill(x,y,fcolor,bcolor)
{
    if(read_pixel(x,y)!=bclor && read_pixel(x,y)!=fcolor)
    {
       write_pixel(x,y,fcolor);
       boundaryfill(x+1,y,fcolor,bcolor);
       boundaryfill(x,y+1,fcolor,bcolor);
       boundaryfill(x-1,y,fcolor,bcolor);
       boundaryfill(x,y-1,fcolor,bcolor);
    }
}
```

#### Polygon filling algorithm:
- Edges of the polygon are first drawn.
- Starting from the seed any point inside the polygon examine the neighbouring pixels to check whether the boundary pixel is reached.
- If the boundary pixels are not reached, pixels are highlighted and the process is repeated.  

**Polygon filling**(*having multiple vertex and multiple edges*)  
- Seed fill
  - Boundary Fill
  - Flood Fill
- Scan line --------> Used for larger polygon.  

***Scan line fill algorithm***  
or  
***Scan line polygon filling algorithm***  
It is used for solid color filling in polygon.  

**Algorithm**:  
```c
function scanline fill()
{
  for each scanline do
  Find the intersection of the scan line with the edges of the polygon sort the intersection by increasing x co-ordinates value;  
  Fill pixels between consecutive pixels of intersections;
}
```

![diagram](IMG/pfill.png)  
In our above example if we follow the step according to our algorithm, we will make a list of all the intersection(6,11),(16,23).  
Now lets sort our intersections by increasing x co-ordinates. So, the order will be 6, 11, 16, 23.  
Now in the final step move pair of intersection so we get two pairs(6,11),(16,23).  
Now fill in all pixels with color inside the pair.  

##### Q15: 4-way neighborhood or 4-connected neighborhood or 4-way adjacency.  
As soon as the filling process is initiated, the neighborhood of the seed point is checked for its color content. For neighboring pixels with old or previous color they are flooded with new color. The neighborhood of a  particular point depends on its connectedness. It is classified as:  
- Four connected neighborhood
- Eight connected neighborhood  

For the current pixel p the 4 and 8 connected neighborhood are shown in the following figure.  
![4waydiagram](IMG/4connected.png) ![8waydiagram](IMG/8connected.png)  

##### Q16: Write down the difference between flood fill algorithm and boundary fill algorithm.  
Sl. |Flood Fill Algorithm | Boundary Fill Algorithm |
----|---------------------|-------------------------|
1. | Flood fill colors an entire area is in enclosed figure through interconnected pixels using a single color. | Here area gets colored with pixels of a chosen color as boundary, giving the technique its name. |
2. | Flood fill is one in which all connected pixels of a selected pixels of a selected color get replaced by a fill color | Boundary fill is very similar with the flood fill, the difference is that the program stopping when a given color boundary is formid |
3. | A flood fill may use an unpredictable amount of memory to finish because it is not known how many sub fills will be spawned. | Boundary fill is usually more complicated but it is a linear algorithm and does not require recursion. |
4. | Time consuming. | It is less time consuming. |


##### Q17: Write down the drawbacks of DDA algorithm.
Drawbacks/Disadvantages of DDA algorithm are as follows:  
- Floating point arithmetic in DDA algorithm is still time consuming.
- The algorithm is orientation dependent. Hence, end point accuracy is poor.
- Rounding-off in DDA is time consuming.

##### Q18: What is scan conversion? Explain different techniques of scan conversion.
Scan conversion is the process of finding the screen pixels that intercepts a polygon. To do this convenient to move to a copy of image space ie scaled to closely correspond to the pixels in our display window.  
There are various scan conversion techniques. Some of the scan conversion technique are given as:  
1. **Polynomial method**: In this technique, the polynomial equation is solved to get the pixel positions of a curve or straight line.  
2. **DDA algorithm**: In this technique, the derivation of a line or a curve is used to find the intermediate pixel positions.
3. **Mid point method**: It is a method from applied mathematics. This method is a one step method for solving differential equation.
4. **Brasenham's algorithm**: Z. E. Bresenham's first describe the line drawing algorithm in 1962. Brasenham's algorithm are similar to mid point algorithm.
